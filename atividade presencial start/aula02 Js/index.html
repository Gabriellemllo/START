<html>
<script>

    
//interpolação de strings


// Valor vs referência 
  function mult(n){ 
     n= n *n 
     return n 
    }

     let num = 10
     let res = mult(num) // quando executar ela sobe para função , quando subir ela vai executar na linha 8 que se torna n= 200 e depois quando ela retornar na linha 9 ela deixa de existir ( resumindo é uma variável temporária).

 
 //referência
 
 
   function multObjc(obj){
      obj.valor = obj.valor * obj.valor // a msm coisa a diferença é que vai ter dois locais e com o msm resultado que é = 100 no lugar de 10 vai alterar e ficar 100 .
      return obj
     } 

    let numObj = {
        valor: 10 // ojeto da minha variável 
     }
    console.log(multObjc(numObj))
    console.log(numObj)

//passagem por referência só funciona para object e array
// parâmetro é um valor que vc passa para uma função. 


// function scoped
    const func = function (n) {
        n = n *n
        return n
    }

    console.log(func(4)) //  no lugar onde está o número 4 : vc pode colocar qualquer número para jogar  p linha  35 e jogar para a multiplicação.



    // const func = function(n1,n2,n3){
        
    //     return res
    // }

    console.log(func(4,3,2))
    // Arrow  Function 

        const func2 = (n) => {
            n = n * n
            return n 
        // pode fazer dessa forma se  o return for só uma linha .
        // const func3 = (n) => (n = n * n)
        // console.log(func3(3))

        }
       

    // Callbacks 

//     function mult(values,func){
//         for(let i=o; i < values.lenght; i++){
//             values[i] = func(values[i])
//         }
//         return values
//     }
//     const values = [1,3,4,6,7,4]

//     const func3 = (n) => n * 2
//     console.log(values)
//     console.log(mult( values,func))

// </script>
// </html>